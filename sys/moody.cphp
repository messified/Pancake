<?php namespace Moody{class Configuration{private static$A=array();public static function load($B){}public static function set($C,$D){return self::$A[$C]=$D;}public static function get($C,$E=null){if(isset(self::$A[$C]))return self::$A[$C];return$E;}}}namespace Moody{class ConstantContainer{private static$F=array();public static function initialize(){foreach(get_defined_constants()as$G=>$H)if(!self::isDefined($G))self::define($G,$H);}public static function getConstant($I){$I=strtolower($I);if(isset(self::$F[$I]))return self::$F[$I];}public static function isDefined($I){return isset(self::$F[strtolower($I)]);}public static function define($I,$D){self::$F[strtolower($I)]=$D;}public static function undefine($I){$I=strtolower($I);if(isset(self::$F[$I]))unset(self::$F[$I]);}}}namespace Moody{const END_TOKEN_NO_EXECUTE=1;const END_TOKEN_EXECUTE=2;class IfInstruction{private static$J=array();private static$K=array();private$L;private$M;private$N=END_TOKEN_EXECUTE;public function __construct(Token$L){self::$J[]=$this;self::$K[]=$this;$this->L=$L;}public static function setEndToken(Token$L){if(!self::$K)throw new InstructionProcessorException('Endif or Else while no if is active',$L);end(self::$K);self::$K[key(self::$K)]->M=$L;unset(self::$K[key(self::$K)]);}public function getToken(){return$this->L;}public function getEndToken(){return$this->M;}public function setEndTokenAction($O){$this->N=$O;}public function getEndTokenAction(){return$this->N;}public static function getAll(){return self::$J;}}}namespace Moody{interface InstructionHandler{public static function getInstance();public function execute(Token$L,$P,TokenHandlers\InstructionProcessor$Q,TokenVM$R);}interface InstructionHandlerWithRegister extends InstructionHandler{public function register(Token$L,$P,TokenHandlers\InstructionProcessor$Q,TokenVM$R);}interface InlineInstructionHandler extends InstructionHandler{public function inlineExecute(Token$L,$P,TokenHandlers\InstructionProcessor$Q);public function execute(Token$L,$P,TokenHandlers\InstructionProcessor$Q,TokenVM$R=null,$S=false);}}namespace Moody{class InstructionProcessorException extends \Exception{private$L;public function __construct($message,Token$L){$this->message=$message;$this->L=$L;}public function __toString(){$B='The Moody Instruction Processor encountered an unexpected error and can not continue'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace:'."\r\n";$B.=$this->getTraceAsString()."\r\n";$B.='Current token:'."\r\n";$B.=(string)$this->L;return$B;}}}namespace Moody{class MoodyException extends \Exception{public function __toString(){$B='Moody encountered an unexpected error and can not continue.'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace: '."\r\n".$this->getTraceAsString();return$B;}}}namespace Moody{define('T_DOT',16384);define('T_UNKNOWN',16385);define('T_ROUND_BRACKET_OPEN',16386);define('T_ROUND_BRACKET_CLOSE',16387);define('T_COMMA',16388);define('T_TRUE',16389);define('T_FALSE',16390);define('T_NULL',16391);define('T_FORCED_WHITESPACE',16392);define('T_SEMICOLON',16393);if(!defined('T_INSTEADOF'))define('T_INSTEADOF',32768);if(!defined('T_TRAIT'))define('T_TRAIT',32769);class Token{public$T=0;public$U=0;public$V=0;public$W="Unknown";public$X=0;public$content="";private static$Y=0;private static$Z=0;private static$a=array(T_ABSTRACT=>"T_ABSTRACT",T_AND_EQUAL=>"T_AND_EQUAL",T_ARRAY=>"T_ARRAY",T_ARRAY_CAST=>"T_ARRAY_CAST",T_AS=>"T_AS",T_BAD_CHARACTER=>"T_BAD_CHARACTER",T_BOOLEAN_AND=>"T_BOOLEAN_AND",T_BOOLEAN_OR=>"T_BOOLEAN_OR",T_BOOL_CAST=>"T_BOOL_CAST",T_BREAK=>"T_BREAK",T_CASE=>"T_CASE",T_CATCH=>"T_CATCH",T_CHARACTER=>"T_CHARACTER",T_CLASS=>"T_CLASS",T_CLASS_C=>"T_CLASS_C",T_CLONE=>"T_CLONE",T_CLOSE_TAG=>"T_CLOSE_TAG",T_COMMA=>"T_COMMA",T_COMMENT=>"T_COMMENT",T_CONCAT_EQUAL=>"T_CONCAT_EQUAL",T_CONST=>"T_CONST",T_CONSTANT_ENCAPSED_STRING=>"T_CONSTANT_ENCAPSED_STRING",T_CONTINUE=>"T_CONTINUE",T_CURLY_OPEN=>"T_CURLY_OPEN",T_DEC=>"T_DEC",T_DECLARE=>"T_DECLARE",T_DEFAULT=>"T_DEFAULT",T_DIR=>"T_DIR",T_DIV_EQUAL=>"T_DIV_EQUAL",T_DNUMBER=>"T_DNUMBER",T_DO=>"T_DO",T_DOC_COMMENT=>"T_DOC_COMMENT",T_DOLLAR_OPEN_CURLY_BRACES=>"T_DOLLAR_OPEN_CURLY_BRACES",T_DOT=>"T_DOT",T_DOUBLE_ARROW=>"T_DOUBLE_ARROW",T_DOUBLE_CAST=>"T_DOUBLE_CAST",T_DOUBLE_COLON=>"T_DOUBLE_COLON",T_ECHO=>"T_ECHO",T_ELSE=>"T_ELSE",T_ELSEIF=>"T_ELSEIF",T_EMPTY=>"T_EMPTY",T_ENCAPSED_AND_WHITESPACE=>"T_ENCAPSED_AND_WHITESPACE",T_ENDDECLARE=>"T_ENDDECLARE",T_ENDFOR=>"T_ENDFOR",T_ENDFOREACH=>"T_ENDFOREACH",T_ENDIF=>"T_ENDIF",T_ENDSWITCH=>"T_ENDSWITCH",T_ENDWHILE=>"T_ENDWHILE",T_END_HEREDOC=>"T_END_HEREDOC",T_EVAL=>"T_EVAL",T_EXIT=>"T_EXIT",T_EXTENDS=>"T_EXTENDS",T_FALSE=>"T_FALSE",T_FILE=>"T_FILE",T_FINAL=>"T_FINAL",T_FOR=>"T_FOR",T_FORCED_WHITESPACE=>"T_FORCED_WHITESPACE",T_FOREACH=>"T_FOREACH",T_FUNCTION=>"T_FUNCTION",T_FUNC_C=>"T_FUNC_C",T_GLOBAL=>"T_GLOBAL",T_GOTO=>"T_GOTO",T_HALT_COMPILER=>"T_HALT_COMPILER",T_OPEN_TAG=>"T_OPEN_TAG",T_ROUND_BRACKET_CLOSE=>"T_ROUND_BRACKET_CLOSE",T_ROUND_BRACKET_OPEN=>"T_ROUND_BRACKET_OPEN",T_SEMICOLON=>"T_SEMICOLON",T_STRING=>"T_STRING",T_TRUE=>"T_TRUE",T_UNKNOWN=>"T_UNKNOWN",T_VARIABLE=>"T_VARIABLE",T_WHITESPACE=>"T_WHITESPACE");public function __construct(){$this->T=self::$Y++;}public static function tokenize($code,$b=null){$Y=token_get_all($code);if(!$Y)throw new MoodyException('Token::tokenize() was called with a non-tokenizable code');$c=array();self::$Z++;foreach($Y as$L){$d=new Token;$d->V=self::$Z;if($b)$d->W=$b;if(is_array($L)){$d->U=$L[0];$d->content=$L[1];$d->X=$L[2];if(strtolower($d->content)=='true')$d->U=T_TRUE;else if(strtolower($d->content)=='false')$d->U=T_FALSE;else if(strtolower($d->content)=='null')$d->U=T_NULL;}else {$d->content=$L;$d->X=-1;switch($L){case'.':$d->U=T_DOT;break;case'(':$d->U=T_ROUND_BRACKET_OPEN;break;case')':$d->U=T_ROUND_BRACKET_CLOSE;break;case',':$d->U=T_COMMA;break;case';':$d->U=T_SEMICOLON;break;default:$d->U=T_UNKNOWN;}}$c[]=$d;}return$c;}public function __toString(){$B='Type: '.(isset(self::$a[$this->U])?self::$a[$this->U]:$this->U)."\r\n";$B.='Content: '.$this->content."\r\n";if($this->W!="Unknown"){$B.='Origin: '.$this->W."\r\n";$B.='Line: '.$this->X."\r\n";}return$B;}public static function makeEvaluatable($D){if(is_string($D))return"'".str_replace("'","\'",$D)."'";if(is_int($D)||is_float($D))return$D;if($D===true)return"true";if($D===false)return"false";if($D===null)return"null";}}}namespace Moody{interface TokenHandler{public static function getInstance();public function execute(Token$L,TokenVM$R);}interface TokenHandlerWithRegister extends TokenHandler{public function register(Token$L,TokenVM$R);}}namespace Moody{class TokenVM{const NEXT_TOKEN=1;const QUIT=2;const NEXT_HANDLER=4;const ERROR=8;const REEXECUTE_TOKEN=16;const REEXECUTE_HANDLER=32;const JUMP=64;const CLEAR_RETVAL=128;const CLEAR_ERROR=256;const DELETE_TOKEN=512;private static$e=array();private$f=array();private$g=array();private$h=array();private$i=null;public function __construct(){$this->f=self::$e;}public function execute($h){if(!$h)throw new VMException('Virtual machine received empty token array');$this->h=$h;$j=0;foreach($this->h as$L){if(isset($this->f[$L->U])){foreach($this->f[$L->U]as$k){if(!is_object($k))throw new VMException('Handler for token is not a object',$L);$l=clone$L;if(is_callable(array($k,'register')))$k->register($L,$this);$L=$l;}reset($this->f[$L->U]);}}reset($this->h);$m=array();nextToken:if(!($L=current($this->h)))goto quit;$n=$L->T;next($this->h);$o=clone$L;executeToken:if(!is_int($n))throw new VMException('Token ID '.$n.' is not an integer');if(!($L instanceof Token))throw new VMException('Element '.$n.' is not a valid token');$this->g[$n]=true;$j=0;nextHandler:if(isset($this->f[$L->U])){if(current($this->f[$L->U])!==false){$k=current($this->f[$L->U]);next($this->f[$L->U]);}else {reset($this->f[$L->U]);goto doRetval;}}else {$m[]=$L;goto nextToken;}executeHandler:if(!is_object($k))throw new VMException('Handler for token is not an object',$L);if(!is_callable(array($k,'execute')))throw new VMException('The execute method of the token handler does not exist or is not callable from the virtual machines\' scope',$L);$p=$k->execute($L,$this);if($p&self::CLEAR_RETVAL)$j=$p;else $j|=$p;doRetval:if($j&self::REEXECUTE_HANDLER){$j^=self::REEXECUTE_HANDLER;goto executeHandler;}if($j&self::NEXT_HANDLER){$j^=self::NEXT_HANDLER;goto nextHandler;}if($j&self::REEXECUTE_TOKEN){$j^=self::REEXECUTE_TOKEN;goto executeToken;}if(!($j&self::DELETE_TOKEN))$m[]=$L;if($j&self::QUIT)goto quit;if($j&self::ERROR&&!($j&self::CLEAR_ERROR))throw new VMException('Token handler returned an error',$L,$o);if($j&self::JUMP){if(!($this->i instanceof Token))throw new VMException('Cannot jump to new token as it is not a token',$L,$o);if(!in_array($this->i,$this->h))throw new VMException('Cannot jump to new token as it is not specified in current token array',$L,$o);if(array_search($this->i,$this->h)<key($this->h)){while(current($this->h)!=$this->i)prev($this->h);}else if(array_search($this->i,$this->h)>key($this->h)){while(current($this->h)!=$this->i)next($this->h);}}if($j&self::NEXT_TOKEN)goto nextToken;throw new VMException('Token handler did not specify an action for the virtual machine',$L,$o);quit:return$m;}public function hasExecuted($n){return isset($this->g[$n]);}public static function globalRegisterTokenHandler($q,TokenHandler$r){if(!isset(self::$e[$q]))self::$e[$q]=array($r);else self::$e[$q][]=$r;}public static function globalUnregisterTokenHandler($q,TokenHandler$r){if(!isset(self::$e[$q])||($s=array_search(self::$f[$q]))===false)return;unset(self::$e[$q][$s]);}public function registerTokenHandler($q,TokenHandler$r){if(!isset($this->f[$q]))$this->f[$q]=array($r);else $this->f[$q][]=$r;}public function unregisterTokenHandler($q,TokenHandler$r){if(!isset($this->f[$q])||($s=array_search($this->f[$q]))===false)return;unset($this->f[$q][$s]);}public function jump(Token$L){$this->i=$L;}public function insertTokenArray($h){reset($h);$t=current($h);while($L=current($this->h)){$u[]=$L;unset($this->h[key($this->h)]);}foreach($h as$L){if(isset($this->f[$L->U])){$s=key($this->f[$L->U]);foreach($this->f[$L->U]as$k){if(!is_object($k))throw new VMException('Handler for token is not a object',$L);$l=clone$L;if(is_callable(array($k,'register')))$k->register($L,$this);$L=$l;}reset($this->f[$L->U]);while(key($this->f[$L->U])!==$s)next($this->f[$L->U]);}$this->h[]=$L;}foreach($u as$L)$this->h[]=$L;$s=array_search($t,$this->h);while(key($this->h)!=$s)prev($this->h);}public function getTokenArray(){return$this->h;}}}namespace Moody{class VMException extends \Exception{private$L;private$o;public function __construct($message,Token$L=null,Token$o=null){$this->message=$message;$this->L=$L;$this->o=$o;}public function __toString(){$B='The Moody Virtual Machine encountered an unexpected error and can not continue'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace:'."\r\n";$B.=$this->getTraceAsString();if($this->L instanceof Token){$B.="\r\n";$B.='Current token:'."\r\n";$B.=(string)$this->L;}if($this->o instanceof Token){$B.="\r\n";$B.='Current token before modification through token handlers:'."\r\n";$B.=(string)$this->o;}return$B;}}}namespace Moody\TokenHandlers{use Moody\TokenHandlerWithRegister;use Moody\TokenVM;use Moody\Token;use Moody\InstructionProcessorException;use Moody\Configuration;use Moody\ConstantContainer;use Moody\InstructionHandler;class InstructionProcessor implements TokenHandlerWithRegister{private static$v=null;private$f=array();public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_COMMENT,$this);}public function execute(Token$L,TokenVM$R){$content=str_replace(array("//","/*","*/","#"),"",$L->content);$w=array();$x=0;if(preg_match('~^\s*(\.([A-Za-z_]+))~',$content,$w)){$y=strtolower($w[2]);if(isset($this->f[$y])){if(!is_callable(array($this->f[$y],'execute')))throw new InstructionProcessorException('Handler for instruction "'.$w[1].'" does not exist or is not callable',$L);$x=$this->f[$y]->execute($L,$w[1],$this,$R);}else if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$w[1].'"',$L);}else if(Configuration::get('deletecomments',false))$x=TokenVM::DELETE_TOKEN;return (TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN)^$x;}public function register(Token$L,TokenVM$R){$content=str_replace(array("//","/*","*/","#"),"",$L->content);$w=array();if(preg_match('~^\s*(\.([A-Za-z_]+))~',$content,$w)){$y=strtolower($w[2]);if(isset($this->f[$y])){if(is_callable(array($this->f[$y],'register')))$this->f[$y]->register($L,$w[1],$this,$R);}}}private function inlineExecute(Token$L){$content=str_replace(array("//","/*","*/","#"),"",$L->content);$w=array();if(preg_match('~^\s*(\.([A-Za-z_]+))~',$content,$w)){$y=strtolower($w[2]);if(isset($this->f[$y])){if(!is_callable(array($this->f[$y],'inlineExecute')))throw new InstructionProcessorException('Handler for instruction "'.$w[1].'" does not support inline execution or is not callable',$L);return$this->f[$y]->inlineExecute($L,$w[1],$this);}else if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$w[1].'"',$L);}}public function registerHandler($y,InstructionHandler$r){$this->f[$y]=$r;}public function parseArguments(Token$z,$P,$i0){if($i0)$i1=str_split($i0);else $i1=array();if(!strpos($z->content,$P))throw new InstructionProcessorException('Token corrupted',$z);if(substr($z->content,0,2)=='/*')$content=substr($z->content,2,strrpos($z->content,'*/')-2);else if(substr($z->content,0,1)=='#')$content=substr($z->content,1);else $content=substr($z->content,2);$i2=substr($content,strpos($content,$P)+strlen($P));$Y=Token::tokenize('<?php '.$i2.' ?>','Moody Argument Parser');foreach($Y as$L)if($L->U==T_COMMA)$i3=true;$i4=0;$i5=0;$i6=$i7=array();$i8=null;parseArgs:foreach($Y as$L){if(isset($i9))goto parseArg;if($L->U==T_OPEN_TAG||$L->U==T_CLOSE_TAG||$L->U==T_ROUND_BRACKET_OPEN||$L->U==T_ROUND_BRACKET_CLOSE||$L->U==T_WHITESPACE||in_array($L,$i7))continue;switch($L->U){case T_STRING:if(ConstantContainer::isDefined($L->content))if($i8!==null)$i8.=ConstantContainer::getConstant($L->content);else $i8=ConstantContainer::getConstant($L->content);else $i8.=$L->content;break;case T_CONSTANT_ENCAPSED_STRING:$i8.=eval('return '.$L->content.';');break;case T_TRUE:if($i8!==null)$i8.=true;else $i8=true;break;case T_FALSE:if($i8!==null)$i8.=false;else $i8=false;break;case T_LNUMBER:if($i8!==null)$i8.=(int)$L->content;else $i8=(int)$L->content;break;case T_DNUMBER:if($i8!==null)$i8.=(float)$L->content;else $i8=(float)$L->content;break;case T_NULL:if($i8!==null)$i8.=null;else $i8=null;break;case T_NS_SEPARATOR:$i10="";$i11=key($Y)-1;prev($Y);while($i12=prev($Y)){if($i12->U!=T_STRING)break;end($i6);unset($i6[key($i6)]);$i10=$i12->content.$i10;}while(key($Y)!=$i11)next($Y);$i10.=$L->content;while($i13=next($Y)){if($i13->U!=T_NS_SEPARATOR&&$i13->U!=T_STRING)break;$i10.=$i13->content;$i7[]=$i13;}if(ConstantContainer::isDefined($i10))if($i8!==null)$i8.=ConstantContainer::getConstant($i10);else $i8=ConstantContainer::getConstant($i10);else $i8.=$i10;break;case T_COMMENT:if($i8!==null)$i8.=$this->inlineExecute($L);else $i8=$this->inlineExecute($L);break;case T_COMMA:goto parseArg;default:if($i8!==null)$i8.=$L->content;else $i8=$L->content;}if(isset($i3))continue;parseArg:if(!isset($i1[$i4+$i5])||!$i1[$i4+$i5]){$i6[]=$i8;}else if($i1[$i4+$i5]=='?'){$i5++;goto parseArg;}else {switch(strtolower($i1[$i4+$i5])){default:throw new InstructionProcessorException('Illegal option for argument parser given: '.$i1[$i4+$i5],$z);case'n':if(is_numeric($i8)&&is_string($i8))$i6[]=(float)$i8;else if(is_int($i8)||is_float($i8)||$i8===null)$i6[]=$i8;else throw new InstructionProcessorException('Illegal argument '.($i4+1).' for '.$P.': '.gettype($i8).' '.(string)$i8.' given, number expected',$z);break;case's':if(is_string($i8)||$i8===null)$i6[]=$i8;else throw new InstructionProcessorException('Illegal argument '.($i4+1).' for '.$P.': '.gettype($i8).' '.(string)$i8.' given, string expected',$z);break;case'b':if(is_bool($i8)||$i8===null)$i6[]=$i8;else throw new InstructionProcessorException('Illegal argument '.($i4+1).' for '.$P.': '.gettype($i8).' '.(string)$i8.' given, bool expected',$z);break;case'x':$i6[]=$i8;}}$i8=null;$i4++;if(isset($i9))break;}if($i8!==null){$i9=true;goto parseArgs;}if((strpos($i0,'?')!==false&&$i4<strpos($i0,'?'))||($i4<count($i1)&&strpos($i0,'?')===false))throw new InstructionProcessorException($P.' expects '.count($i1).' arguments, '.$i4.' given',$z);return$i6;}}}namespace Moody\TokenHandlers{use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class DocCommentHandler implements TokenHandler{private static$v=null;public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_DOC_COMMENT,$this);}public function execute(Token$L,TokenVM$R){if(Configuration::get('deletecomments',false))return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN|TokenVM::DELETE_TOKEN;return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}}}namespace Moody\TokenHandlers{use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;class OpenTagHandler implements TokenHandler{private static$v=null;public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_OPEN_TAG,$this);}public function execute(Token$L,TokenVM$R){if($L->content=='<?'||$L->content=='<%')$L->content='<?php ';return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}}}namespace Moody\TokenHandlers{use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class VariableHandler implements TokenHandler{private static$v=null;private$i14=array();private$i15="A";public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_VARIABLE,$this);TokenVM::globalRegisterTokenHandler(T_OBJECT_OPERATOR,$this);}public function execute(Token$L,TokenVM$R){static$i16=array('$this','$_GET','$_POST','$_REQUEST','$_COOKIE','$_ENV','$_SESSION','$_SERVER','$_FILES');if(Configuration::get('compressvariables',false)&&!in_array($L->content,$i16)){if($L->U==T_OBJECT_OPERATOR){if(!Configuration::get('compressproperties',false))return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;$h=$R->getTokenArray();$i17=current($h);if($i17->U!=T_STRING)goto end;while($i18=next($h)){if($i18->U==T_WHITESPACE)continue;if($i18->U==T_ROUND_BRACKET_OPEN)goto end;break;}$i19=$i17;$i19->content='$'.$i19->content;}else $i19=$L;if(!isset($this->i14[$i19->content])){if(!Configuration::get('compressproperties',false)){$h=$R->getTokenArray();prev($h);while($i18=prev($h)){switch($i18->U){case T_STATIC:$i20=true;goto map;default:if(!isset($i20)&&isset($i21))goto end;goto map;case T_PUBLIC:case T_PROTECTED:case T_PRIVATE:$i21=true;case T_WHITESPACE:case T_FORCED_WHITESPACE:continue 2;}}}map:do{$this->mapVariable($i19->content,is_int($this->i15)?'$i'.$this->i15:'$'.$this->i15);if($this->i15==="Z")$this->i15="a";else if($this->i15==="z")$this->i15=0;else if(is_int($this->i15))$this->i15++;else $this->i15=chr(ord($this->i15)+1);}while(count(array_keys($this->i14,$this->i14[$i19->content]))>1);}$i19->content=isset($i17)?substr($this->i14[$i19->content],1):$this->i14[$i19->content];}end:return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}public function mapVariable($i22,$i23){return$this->i14[$i22]=$i23;}}}namespace Moody\TokenHandlers{use Moody\TokenHandler;use Moody\TokenVM;use Moody\Configuration;use Moody\Token;class WhitespaceHandler implements TokenHandler{private static$v=null;public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}private function __construct(){if(Configuration::get('supportwhitespacedeletion',true)){TokenVM::globalRegisterTokenHandler(T_WHITESPACE,$this);TokenVM::globalRegisterTokenHandler(T_ECHO,$this);TokenVM::globalRegisterTokenHandler(T_VARIABLE,$this);TokenVM::globalRegisterTokenHandler(T_GOTO,$this);TokenVM::globalRegisterTokenHandler(T_ELSE,$this);TokenVM::globalRegisterTokenHandler(T_NAMESPACE,$this);TokenVM::globalRegisterTokenHandler(T_CONST,$this);TokenVM::globalRegisterTokenHandler(T_NEW,$this);TokenVM::globalRegisterTokenHandler(T_INSTANCEOF,$this);TokenVM::globalRegisterTokenHandler(T_INSTEADOF,$this);TokenVM::globalRegisterTokenHandler(T_STRING,$this);TokenVM::globalRegisterTokenHandler(T_CLASS,$this);TokenVM::globalRegisterTokenHandler(T_EXTENDS,$this);TokenVM::globalRegisterTokenHandler(T_PUBLIC,$this);TokenVM::globalRegisterTokenHandler(T_PROTECTED,$this);TokenVM::globalRegisterTokenHandler(T_PRIVATE,$this);TokenVM::globalRegisterTokenHandler(T_FINAL,$this);TokenVM::globalRegisterTokenHandler(T_STATIC,$this);TokenVM::globalRegisterTokenHandler(T_FUNCTION,$this);TokenVM::globalRegisterTokenHandler(T_RETURN,$this);TokenVM::globalRegisterTokenHandler(T_CASE,$this);TokenVM::globalRegisterTokenHandler(T_START_HEREDOC,$this);TokenVM::globalRegisterTokenHandler(T_SEMICOLON,$this);TokenVM::globalRegisterTokenHandler(T_END_HEREDOC,$this);TokenVM::globalRegisterTokenHandler(T_BREAK,$this);TokenVM::globalRegisterTokenHandler(T_CONTINUE,$this);TokenVM::globalRegisterTokenHandler(T_USE,$this);TokenVM::globalRegisterTokenHandler(T_THROW,$this);TokenVM::globalRegisterTokenHandler(T_INTERFACE,$this);TokenVM::globalRegisterTokenHandler(T_TRAIT,$this);TokenVM::globalRegisterTokenHandler(T_IMPLEMENTS,$this);}}public function execute(Token$L,TokenVM$R){if(Configuration::get('deletewhitespaces',false)){switch($L->U){case T_WHITESPACE:$h=$R->getTokenArray();if(($i18=current($h))&&$i18->U==T_END_HEREDOC)$this->insertForcedWhitespace($R,true);return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN|TokenVM::DELETE_TOKEN;case T_ECHO:case T_RETURN:case T_PUBLIC:case T_PROTECTED:case T_PRIVATE:case T_STATIC:case T_FINAL:case T_CASE:case T_CONTINUE:case T_BREAK:case T_THROW:$h=$R->getTokenArray();if($i18=current($h)){if($i18->U!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i18=next($h))&&$i18->U!=T_CONSTANT_ENCAPSED_STRING&&$i18->U!=T_VARIABLE)$this->insertForcedWhitespace($R);}break;case T_VARIABLE:$h=$R->getTokenArray();if($i18=current($h)){if($i18->U!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i18=next($h))&&($i18->U==T_AS||$i18->U==T_INSTANCEOF))$this->insertForcedWhitespace($R);}break;case T_GOTO:case T_NAMESPACE:case T_CONST:case T_NEW:case T_INSTANCEOF:case T_INSTEADOF:case T_CLASS:case T_EXTENDS:case T_FUNCTION:case T_START_HEREDOC:case T_USE:case T_INTERFACE:case T_TRAIT:case T_IMPLEMENTS:$this->insertForcedWhitespace($R);break;case T_ELSE:$h=$R->getTokenArray();if($i18=current($h)){if($i18->U!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i18=next($h))&&$i18->U!=T_CURLY_OPEN)$this->insertForcedWhitespace($R);}break;case T_STRING:$h=$R->getTokenArray();if($i18=current($h)){if($i18->U!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i18=next($h))&&($i18->U==T_EXTENDS||$i18->U==T_INSTEADOF||$i18->U==T_INSTANCEOF||$i18->U==T_AS||$i18->U==T_IMPLEMENTS))$this->insertForcedWhitespace($R);}break;case T_SEMICOLON:$h=$R->getTokenArray();prev($h);$i18=prev($h);if($i18->U==T_END_HEREDOC)$this->insertForcedWhitespace($R,true);break;case T_END_HEREDOC:$h=$R->getTokenArray();if(($i18=current($h))&&$i18->U!=T_SEMICOLON)$this->insertForcedWhitespace($R,true);break;}}end:return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}private function insertForcedWhitespace(TokenVM$R,$i24=false){$L=new Token;$L->content=$i24?"\r\n":" ";$L->U=T_FORCED_WHITESPACE;$L->W="Moody WhitespaceHandler";$R->insertTokenArray(array($L));}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class BooleanCastHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('bool',$this);InstructionProcessor::getInstance()->registerHandler('boolean',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'x');if($S)return (bool)$i6[0];$L->content=Token::makeEvaluatable((bool)$i6[0]);return 0;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class CallHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('call',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'s');if(strpos($i6[0],'::')){$i25=explode('::',$i6[0],2);$i26=array($i25[0],$i25[1]);if(!method_exists($i25[0],$i25[1]))throw new InstructionProcessorException($i6[0].'() does not exist',$L);}else {$i26=$i6[0];if(!function_exists($i26))throw new InstructionProcessorException($i6[0].'() does not exist',$L);}if(!is_callable($i26))throw new InstructionProcessorException($i6[0].'() is not callable from the current scope',$L);$i27=$i6;unset($i27[0]);$D=call_user_func_array($i26,$i27);if($S)return$D;$L->content=Token::makeEvaluatable($D);return 0;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\Configuration;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ConfigurationHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('config',$this);InstructionProcessor::getInstance()->registerHandler('configuration',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'s?x');if(!isset($i6[1])){if($S)return Configuration::get($i6[0],null);$L->content=Token::makeEvaluatable(Configuration::get($i6[0],null));return 0;}else Configuration::set($i6[0],$i6[1]);return TokenVM::DELETE_TOKEN;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class GetConstantHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('const',$this);InstructionProcessor::getInstance()->registerHandler('constant',$this);InstructionProcessor::getInstance()->registerHandler('getconstant',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'s');if(!ConstantContainer::isDefined($i6[0]))throw new InstructionProcessorException($P.': Undefined constant: '.$i6[0],$L);$i28=ConstantContainer::getConstant($i6[0]);if($S)return$i28;$L->content=Token::makeEvaluatable($i28);return 0;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\ConstantContainer;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class DefineHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('define',$this);InstructionProcessor::getInstance()->registerHandler('def',$this);InstructionProcessor::getInstance()->registerHandler('d',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'sx');ConstantContainer::define($i6[0],$i6[1]);return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class EchoHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('echo',$this);InstructionProcessor::getInstance()->registerHandler('print',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'x');foreach($i6 as$i29)echo (string)$i29;return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\END_TOKEN_NO_EXECUTE;use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ElseHandler implements InstructionHandlerWithRegister{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('else',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){foreach(IfInstruction::getAll()as$y){if($y->getToken()==$L){if(!($y->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$P.' - Probably you forgot an endif?',$L);$i30=$y;}}foreach(IfInstruction::getAll()as$y){if($y->getEndToken()==$L){if($y->getEndTokenAction()==\Moody\END_TOKEN_NO_EXECUTE){$i30->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);$R->jump($i30->getEndToken());return TokenVM::DELETE_TOKEN|TokenVM::JUMP;}}}return TokenVM::DELETE_TOKEN;}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){IfInstruction::setEndToken($L);new IfInstruction($L);}}}namespace Moody\InstructionHandlers{use Moody\END_TOKEN_NO_EXECUTE;use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ElseIfHandler implements InstructionHandlerWithRegister{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('elseif',$this);InstructionProcessor::getInstance()->registerHandler('elif',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){foreach(IfInstruction::getAll()as$y){if($y->getToken()==$L){if(!($y->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$P.' - Probably you forgot an endif?',$L);$i30=$y;}}foreach(IfInstruction::getAll()as$y){if($y->getEndToken()==$L){if($y->getEndTokenAction()==\Moody\END_TOKEN_NO_EXECUTE){$i30->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);$R->jump($i30->getEndToken());return TokenVM::DELETE_TOKEN|TokenVM::JUMP;}}}return IfHandler::getInstance()->execute($L,$P,$Q,$R);}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){IfInstruction::setEndToken($L);new IfInstruction($L);}}}namespace Moody\InstructionHandlers{use Moody\TokenHandlers\InstructionProcessor;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenVM;use Moody\IfInstruction;class EndIfHandler implements InstructionHandlerWithRegister{private static$v;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endif',$this);}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){return TokenVM::DELETE_TOKEN;}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){IfInstruction::setEndToken($L);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class EvalHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('eval',$this);InstructionProcessor::getInstance()->registerHandler('evaluate',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'s?bb');if(!isset($i6[1])||$i6[1]===true){if(!strpos($i6[0],'<?')){$i31=true;$h=Token::tokenize('<?php '.$i6[0].' ?>',$P.' code');}else $h=Token::tokenize($i6[0],$P.' code');$R=new TokenVM();try{$h=$R->execute($h);}catch(\Exception$i32){echo (string)$i32."\r\n";exit;}if(isset($i31)){reset($h);unset($h[key($h)]);end($h);unset($h[key($h)]);}$i6[0]="";foreach($h as$i33){$i6[0].=$i33->content;}}$i34=eval($i6[0]);if($i34!==null){if($S)return$i34;$L->content=!isset($i6[2])||$i6[2]===true?Token::makeEvaluatable($i34):$i34;return 0;}return TokenVM::DELETE_TOKEN;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ExitHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('exit',$this);InstructionProcessor::getInstance()->registerHandler('halt',$this);InstructionProcessor::getInstance()->registerHandler('quit',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){return TokenVM::QUIT|TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class GotoHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('goto',$this);InstructionProcessor::getInstance()->registerHandler('jump',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'s');$i35=LabelHandler::getLabel($i6[0]);if(!($i35 instanceof Token))throw new InstructionProcessorException('Jump to undefined label '.$i6[0],$L);$R->jump($i35);return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\END_TOKEN_ELSE;use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IfHandler implements InstructionHandlerWithRegister{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('if',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'x');foreach(IfInstruction::getAll()as$y){if($y->getToken()==$L){if(!($y->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$P.' - Probably you forgot an endif?',$L);$i36="";$i34=false;foreach($i6 as$i29){if(is_string($i29)&&strtolower($i29)!=="true"&&strtolower($i29)!=="false"){$Y=Token::tokenize('<?php '.$i29.' ?>');if($Y[1]->U==T_STRING)$i29=Token::makeEvaluatable($i29);}else if(is_string($i29)&&!strlen($i29))$i29="''";if($i29===true)$i29="true";else if($i29===false)$i29="false";else if($i29===null)$i29="null";$i36.=$i29;}$i34=eval('return (int) (bool) ('.$i36.');');if($i34===1){$y->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);return TokenVM::DELETE_TOKEN;}if($i34===false)throw new InstructionProcessorException('If-condition '.$i36.' is invalid',$L);$R->jump($y->getEndToken());return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){new IfInstruction($L);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IfDefHandler implements InstructionHandlerWithRegister{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifdef',$this);InstructionProcessor::getInstance()->registerHandler('ifdefined',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'s');foreach(IfInstruction::getAll()as$y){if($y->getToken()==$L){if(!($y->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$P.' - Probably you forgot an endif?',$L);if(ConstantContainer::isDefined($i6[0])){$y->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);return TokenVM::DELETE_TOKEN;}$R->jump($y->getEndToken());return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){new IfInstruction($L);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IfNotDefHandler implements InstructionHandlerWithRegister{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifndef',$this);InstructionProcessor::getInstance()->registerHandler('ifnotdefined',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'s');foreach(IfInstruction::getAll()as$y){if($y->getToken()==$L){if(!($y->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$P.' - Probably you forgot an endif?',$L);if(!ConstantContainer::isDefined($i6[0])){$y->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);return TokenVM::DELETE_TOKEN;}$R->jump($y->getEndToken());return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){new IfInstruction($L);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IncludeHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('include',$this);InstructionProcessor::getInstance()->registerHandler('inc',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'s');if(!file_exists($i6[0]))throw new InstructionProcessorException($i6[0].' does not exist',$L);if(!is_readable($i6[0]))throw new InstructionProcessorException($i6[0].' is not readable - Make sure Moody has the rights to read it',$L);$b=file_get_contents($i6[0]);$Y=Token::tokenize($b,$i6[0]);switch($Y[0]->U){case T_OPEN_TAG:unset($Y[0]);break;case T_INLINE_HTML:$L=new Token;$L->U=T_CLOSE_TAG;$L->content=" ?>";$i37=array($L);foreach($Y as$L)$i37[]=$L;$Y=$i37;}end($Y);switch(current($Y)->U){case T_CLOSE_TAG:unset($Y[key($Y)]);break;case T_INLINE_HTML:$L=new Token;$L->U=T_OPEN_TAG;$L->content="<?php ";$Y[]=$L;}$R->insertTokenArray($Y);return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IsDefinedHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('isdefined',$this);InstructionProcessor::getInstance()->registerHandler('isdef',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'s');if(ConstantContainer::isDefined($i6[0])){if($S)return true;$L->content=Token::makeEvaluatable(true);}else {if($S)return false;$L->content=Token::makeEvaluatable(false);}return 0;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class LabelHandler implements InstructionHandlerWithRegister{private static$v=null;private static$i38=array();private function __construct(){InstructionProcessor::getInstance()->registerHandler('label',$this);InstructionProcessor::getInstance()->registerHandler('jumplabel',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){return TokenVM::DELETE_TOKEN;}public function register(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'s');if(isset(self::$i38[$i6[0]]))throw new InstructionProcessorException('Double definition of jump label "'.$i6[0].'" (first definition at '.self::$i38[$i6[0]]->W.':'.self::$i38[$i6[0]]->X,$L);self::$i38[$i6[0]]=$L;}public static function getLabel($I){if(isset(self::$i38[$I]))return self::$i38[$I];}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class MacroHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('macro',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null){if(strtolower($P)=='.macro'){$i6=$Q->parseArguments($L,$P,'ss');if(!strlen($i6[0]))throw new InstructionProcessorException('Macro name cannot be empty',$L);$i39=new Macro(strtolower($i6[0]),$i6[1]);$Q->registerHandler(strtolower($i6[0]),$this);unset($i6[0],$i6[1]);foreach($i6 as$i29)$i39->addArgument($i29);return TokenVM::DELETE_TOKEN;}$i40=substr(strtolower($P),1);$i39=Macro::getMacro($i40);if(!$i39)throw new InstructionProcessorException('Call to bad macro',$L);$i1="";for($i41=0;$i41<$i39->numArgs();$i41++)$i1.='x';$i6=$Q->parseArguments($L,$P,$i1);$R->insertTokenArray($i39->buildCode($i6));return TokenVM::DELETE_TOKEN;}}class Macro{private$I="";private$code="";private$i42=array();private static$i43=array();public function __construct($I,$code){$this->I=$I;$this->code=$code;self::$i43[$I]=$this;}public function addArgument($i44){$this->i42[]=$i44;}public function numArgs(){return count($this->i42);}public function buildCode($i6=array()){$i41=0;$code=$this->code;foreach($this->i42 as$i29){$code=str_replace($i29,$i6[$i41],$code);$i41++;}$Y=Token::tokenize('<?php '.$code,'Macro '.$this->I);unset($Y[0]);return$Y;}public static function getMacro($I){if(isset(self::$i43[$I]))return self::$i43[$I];}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenHandlers\VariableHandler;use Moody\TokenVM;class MapVariableHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('mapvariable',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'ss');if(!class_exists('Moody\TokenHandlers\VariableHandler'))throw new InstructionProcessorException('Variable mapping is not available as the token handler for T_VARIABLE is not currently loaded',$L);VariableHandler::getInstance()->mapVariable($i6[0],$i6[1]);return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class NumberCastHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('number',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'x');if($S)return (float)$i6[0];$L->content=Token::makeEvaluatable((float)$i6[0]);return 0;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class RaiseErrorHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('raiseerror',$this);InstructionProcessor::getInstance()->registerHandler('error',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'s');throw new InstructionProcessorException($i6[0],$L);}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class StringCastHandler implements InlineInstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('string',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R=null,$S=false){$i6=$Q->parseArguments($L,$P,'x');if($S)return (string)$i6[0];$L->content=Token::makeEvaluatable((string)$i6[0]);return 0;}public function inlineExecute(Token$L,$P,InstructionProcessor$Q){return$this->execute($L,$P,$Q,null,true);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\IfInstruction;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class UndefineHandler implements InstructionHandler{private static$v=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('undef',$this);InstructionProcessor::getInstance()->registerHandler('undefine',$this);}public static function getInstance(){if(!self::$v)self::$v=new self;return self::$v;}public function execute(Token$L,$P,InstructionProcessor$Q,TokenVM$R){$i6=$Q->parseArguments($L,$P,'s');if(!ConstantContainer::isDefined($i6[0]))throw new InstructionProcessorException($P.': Undefined constant: '.$i6[0],$L);ConstantContainer::undefine($i6[0]);return TokenVM::DELETE_TOKEN;}}}?>