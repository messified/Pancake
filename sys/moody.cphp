<?php namespace Moody{class Configuration{private static$A=array();public static function load($B){}public static function set($C,$D){return self::$A[strtolower($C)]=$D;}public static function get($C,$E=null){$C=strtolower($C);if(isset(self::$A[$C]))return self::$A[$C];return$E;}}}namespace Moody{class ConstantContainer{private static$F=array();public static function initialize(){foreach(get_defined_constants()as$G=>$H)if(!self::isDefined($G))self::define($G,$H);}public static function getConstant($I){$I=strtolower($I);if(isset(self::$F[$I]))return self::$F[$I];}public static function isDefined($I){return isset(self::$F[strtolower($I)]);}public static function define($I,$D){self::$F[strtolower($I)]=$D;}public static function undefine($I){$I=strtolower($I);if(isset(self::$F[$I]))unset(self::$F[$I]);}}}namespace Moody{const END_TOKEN_NO_EXECUTE=1;const END_TOKEN_EXECUTE=2;class MultiTokenInstruction{private static$J=array();private static$K=array();private$L;private$M;private$N=END_TOKEN_EXECUTE;public function __construct(Token$L,$O){self::$J[$O][]=$this;self::$K[$O][]=$this;$this->L=$L;}public static function setEndToken(Token$L,$O){if(!isset(self::$K[$O])||!self::$K[$O])throw new InstructionProcessorException('End token of type '.$O.' while not active',$L);end(self::$K[$O]);self::$K[$O][key(self::$K[$O])]->M=$L;unset(self::$K[$O][key(self::$K[$O])]);}public function getToken(){return$this->L;}public function getEndToken(){return$this->M;}public function setEndTokenAction($P){$this->N=$P;}public function getEndTokenAction(){return$this->N;}public static function getAll($O){return self::$J[$O];}}}namespace Moody{interface InstructionHandler{public static function getInstance();public function execute(Token$L,$Q,TokenHandlers\InstructionProcessor$R,TokenVM$S);}interface InstructionHandlerWithRegister extends InstructionHandler{public function register(Token$L,$Q,TokenHandlers\InstructionProcessor$R,TokenVM$S);}interface InlineInstructionHandler extends InstructionHandler{public function execute(Token$L,$Q,TokenHandlers\InstructionProcessor$R,TokenVM$S=null,$T=0);}interface DefaultInstructionHandler extends InstructionHandler{public function execute(Token$L,$Q,TokenHandlers\InstructionProcessor$R,TokenVM$S=null,$T=0);public function canExecute(Token$L,$Q,TokenHandlers\InstructionProcessor$R);}}namespace Moody{class InstructionProcessorException extends \Exception{private$L;public function __construct($message,Token$L){$this->message=$message;$this->L=$L;}public function __toString(){$B='The Moody Instruction Processor encountered an unexpected error and can not continue'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace:'."\r\n";$B.=$this->getTraceAsString()."\r\n";$B.='Current token:'."\r\n";$B.=(string)$this->L;return$B;}}}namespace Moody{class MoodyException extends \Exception{public function __toString(){$B='Moody encountered an unexpected error and can not continue.'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace: '."\r\n".$this->getTraceAsString();return$B;}}}namespace Moody{define('T_DOT',16384);define('T_UNKNOWN',16385);define('T_ROUND_BRACKET_OPEN',16386);define('T_ROUND_BRACKET_CLOSE',16387);define('T_COMMA',16388);define('T_TRUE',16389);define('T_FALSE',16390);define('T_NULL',16391);define('T_FORCED_WHITESPACE',16392);define('T_SEMICOLON',16393);if(!defined('T_INSTEADOF'))define('T_INSTEADOF',32768);if(!defined('T_TRAIT'))define('T_TRAIT',32769);class Token{public$U=0;public$V=0;public$W=0;public$X="Unknown";public$Y=0;public$content="";public$Z=array();private static$a=0;private static$b=0;private static$c=array(T_ABSTRACT=>"T_ABSTRACT",T_AND_EQUAL=>"T_AND_EQUAL",T_ARRAY=>"T_ARRAY",T_ARRAY_CAST=>"T_ARRAY_CAST",T_AS=>"T_AS",T_BAD_CHARACTER=>"T_BAD_CHARACTER",T_BOOLEAN_AND=>"T_BOOLEAN_AND",T_BOOLEAN_OR=>"T_BOOLEAN_OR",T_BOOL_CAST=>"T_BOOL_CAST",T_BREAK=>"T_BREAK",T_CASE=>"T_CASE",T_CATCH=>"T_CATCH",T_CHARACTER=>"T_CHARACTER",T_CLASS=>"T_CLASS",T_CLASS_C=>"T_CLASS_C",T_CLONE=>"T_CLONE",T_CLOSE_TAG=>"T_CLOSE_TAG",T_COMMA=>"T_COMMA",T_COMMENT=>"T_COMMENT",T_CONCAT_EQUAL=>"T_CONCAT_EQUAL",T_CONST=>"T_CONST",T_CONSTANT_ENCAPSED_STRING=>"T_CONSTANT_ENCAPSED_STRING",T_CONTINUE=>"T_CONTINUE",T_CURLY_OPEN=>"T_CURLY_OPEN",T_DEC=>"T_DEC",T_DECLARE=>"T_DECLARE",T_DEFAULT=>"T_DEFAULT",T_DIR=>"T_DIR",T_DIV_EQUAL=>"T_DIV_EQUAL",T_DNUMBER=>"T_DNUMBER",T_DO=>"T_DO",T_DOC_COMMENT=>"T_DOC_COMMENT",T_DOLLAR_OPEN_CURLY_BRACES=>"T_DOLLAR_OPEN_CURLY_BRACES",T_DOT=>"T_DOT",T_DOUBLE_ARROW=>"T_DOUBLE_ARROW",T_DOUBLE_CAST=>"T_DOUBLE_CAST",T_DOUBLE_COLON=>"T_DOUBLE_COLON",T_ECHO=>"T_ECHO",T_ELSE=>"T_ELSE",T_ELSEIF=>"T_ELSEIF",T_EMPTY=>"T_EMPTY",T_ENCAPSED_AND_WHITESPACE=>"T_ENCAPSED_AND_WHITESPACE",T_ENDDECLARE=>"T_ENDDECLARE",T_ENDFOR=>"T_ENDFOR",T_ENDFOREACH=>"T_ENDFOREACH",T_ENDIF=>"T_ENDIF",T_ENDSWITCH=>"T_ENDSWITCH",T_ENDWHILE=>"T_ENDWHILE",T_END_HEREDOC=>"T_END_HEREDOC",T_EVAL=>"T_EVAL",T_EXIT=>"T_EXIT",T_EXTENDS=>"T_EXTENDS",T_FALSE=>"T_FALSE",T_FILE=>"T_FILE",T_FINAL=>"T_FINAL",T_FOR=>"T_FOR",T_FORCED_WHITESPACE=>"T_FORCED_WHITESPACE",T_FOREACH=>"T_FOREACH",T_FUNCTION=>"T_FUNCTION",T_FUNC_C=>"T_FUNC_C",T_GLOBAL=>"T_GLOBAL",T_GOTO=>"T_GOTO",T_HALT_COMPILER=>"T_HALT_COMPILER",T_OPEN_TAG=>"T_OPEN_TAG",T_ROUND_BRACKET_CLOSE=>"T_ROUND_BRACKET_CLOSE",T_ROUND_BRACKET_OPEN=>"T_ROUND_BRACKET_OPEN",T_SEMICOLON=>"T_SEMICOLON",T_STRING=>"T_STRING",T_TRUE=>"T_TRUE",T_UNKNOWN=>"T_UNKNOWN",T_VARIABLE=>"T_VARIABLE",T_WHITESPACE=>"T_WHITESPACE");public function __construct(){$this->U=self::$a++;}public static function tokenize($code,$d=null){$a=token_get_all($code);if(!$a)throw new MoodyException('Token::tokenize() was called with a non-tokenizable code');$e=array();self::$b++;foreach($a as$L){$f=new Token;$f->W=self::$b;if($d)$f->X=$d;if(is_array($L)){$f->V=$L[0];$f->content=$L[1];$f->Y=$L[2];if(strtolower($f->content)=='true')$f->V=T_TRUE;else if(strtolower($f->content)=='false')$f->V=T_FALSE;else if(strtolower($f->content)=='null')$f->V=T_NULL;}else {$f->content=$L;$f->Y=-1;switch($L){case'.':$f->V=T_DOT;break;case'(':$f->V=T_ROUND_BRACKET_OPEN;break;case')':$f->V=T_ROUND_BRACKET_CLOSE;break;case',':$f->V=T_COMMA;break;case';':$f->V=T_SEMICOLON;break;default:$f->V=T_UNKNOWN;}}$e[]=$f;}return$e;}public function __toString(){$B='Type: '.(isset(self::$c[$this->V])?self::$c[$this->V]:$this->V)."\r\n";$B.='Content: '.$this->content."\r\n";if($this->X!="Unknown"){$B.='Origin: '.$this->X."\r\n";$B.='Line: '.$this->Y."\r\n";}return$B;}public static function makeEvaluatable($D){if(is_string($D))return"'".str_replace("'","\'",$D)."'";if(is_int($D)||is_float($D))return$D;if($D===true)return"true";if($D===false)return"false";if($D===null)return"null";}}}namespace Moody{interface TokenHandler{public static function getInstance();public function execute(Token$L,TokenVM$S);}interface TokenHandlerWithRegister extends TokenHandler{public function register(Token$L,TokenVM$S);}}namespace Moody{const MOODY_VERSION="1.0";class TokenVM{const NEXT_TOKEN=1;const QUIT=2;const NEXT_HANDLER=4;const ERROR=8;const REEXECUTE_TOKEN=16;const REEXECUTE_HANDLER=32;const JUMP=64;const CLEAR_RETVAL=128;const CLEAR_ERROR=256;const DELETE_TOKEN=512;private static$g=array();private$h=array();private$i=array();private$j=array();private$k=null;public function __construct(){$this->h=self::$g;}public function execute($j){if(!$j)throw new VMException('Virtual machine received empty token array');$this->j=$j;$l=0;foreach($this->j as$L){if(isset($this->h[$L->V])){foreach($this->h[$L->V]as$m){if(!is_object($m))throw new VMException('Handler for token is not a object',$L);$n=clone$L;if(is_callable(array($m,'register')))$m->register($L,$this);if($L!=$n)throw new VMException('Token corrupted in register step',$L,$n);}reset($this->h[$L->V]);}}reset($this->j);$o=array();nextToken:if(!($L=current($this->j)))goto quit;$p=$L->U;next($this->j);$q=clone$L;executeToken:if(!is_int($p))throw new VMException('Token ID '.$p.' is not an integer');if(!($L instanceof Token))throw new VMException('Element '.$p.' is not a valid token');$this->i[$p]=true;$l=0;nextHandler:if(isset($this->h[$L->V])){if(current($this->h[$L->V])!==false){$m=current($this->h[$L->V]);next($this->h[$L->V]);}else {reset($this->h[$L->V]);goto doRetval;}}else {$o[]=$L;goto nextToken;}executeHandler:if(!is_object($m))throw new VMException('Handler for token is not an object',$L);if(!is_callable(array($m,'execute')))throw new VMException('The execute method of the token handler does not exist or is not callable from the virtual machines\' scope',$L);$r=$m->execute($L,$this);if($r&self::CLEAR_RETVAL)$l=$r;else $l|=$r;doRetval:if($l&self::REEXECUTE_HANDLER){$l^=self::REEXECUTE_HANDLER;goto executeHandler;}if($l&self::NEXT_HANDLER){$l^=self::NEXT_HANDLER;goto nextHandler;}if($l&self::REEXECUTE_TOKEN){$l^=self::REEXECUTE_TOKEN;goto executeToken;}if(!($l&self::DELETE_TOKEN))$o[]=$L;if($l&self::QUIT)goto quit;if($l&self::ERROR&&!($l&self::CLEAR_ERROR))throw new VMException('Token handler returned an error',$L,$q);if($l&self::JUMP){if(!($this->k instanceof Token))throw new VMException('Cannot jump to new token as it is not a token',$L,$q);if(!in_array($this->k,$this->j))throw new VMException('Cannot jump to new token as it is not specified in current token array',$L,$q);if(array_search($this->k,$this->j)<key($this->j)){while(current($this->j)!=$this->k)prev($this->j);}else if(array_search($this->k,$this->j)>key($this->j)){while(current($this->j)!=$this->k)next($this->j);}}if($l&self::NEXT_TOKEN)goto nextToken;throw new VMException('Token handler did not specify an action for the virtual machine',$L,$q);quit:return$o;}public function hasExecuted($p){return isset($this->i[$p]);}public static function globalRegisterTokenHandler($s,TokenHandler$t){if(!isset(self::$g[$s]))self::$g[$s]=array($t);else self::$g[$s][]=$t;}public static function globalUnregisterTokenHandler($s,TokenHandler$t){if(!isset(self::$g[$s])||($u=array_search(self::$h[$s]))===false)return;unset(self::$g[$s][$u]);}public function registerTokenHandler($s,TokenHandler$t){if(!isset($this->h[$s]))$this->h[$s]=array($t);else $this->h[$s][]=$t;}public function unregisterTokenHandler($s,TokenHandler$t){if(!isset($this->h[$s])||($u=array_search($this->h[$s]))===false)return;unset($this->h[$s][$u]);}public function jump(Token$L){$this->k=$L;}public function insertTokenArray($j){reset($j);$v=current($j);while($L=current($this->j)){$w[]=$L;unset($this->j[key($this->j)]);}foreach($j as$L){if(isset($this->h[$L->V])){$u=key($this->h[$L->V]);foreach($this->h[$L->V]as$m){if(!is_object($m))throw new VMException('Handler for token is not a object',$L);$n=clone$L;if(is_callable(array($m,'register')))$m->register($L,$this);if($L!=$n)throw new VMException('Token corrupted in register step',$L,$n);}reset($this->h[$L->V]);while(key($this->h[$L->V])!==$u)next($this->h[$L->V]);}$this->j[]=$L;}foreach($w as$L)$this->j[]=$L;$u=array_search($v,$this->j);while(key($this->j)!=$u)prev($this->j);}public function getTokenArray(){return$this->j;}}}namespace Moody{class VMException extends \Exception{private$L;private$q;public function __construct($message,Token$L=null,Token$q=null){$this->message=$message;$this->L=$L;$this->q=$q;}public function __toString(){$B='The Moody Virtual Machine encountered an unexpected error and can not continue'."\r\n";$B.='Exception message: '.$this->message."\r\n";$B.='System backtrace:'."\r\n";$B.=$this->getTraceAsString();if($this->L instanceof Token){$B.="\r\n";$B.='Current token:'."\r\n";$B.=(string)$this->L;}if($this->q instanceof Token){$B.="\r\n";$B.='Current token before modification by token handlers:'."\r\n";$B.=(string)$this->q;}return$B;}}}namespace Moody\TokenHandlers{use Moody\InstructionHandlerWithRegister;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\TokenHandlerWithRegister;use Moody\TokenVM;use Moody\Token;use Moody\InstructionProcessorException;use Moody\Configuration;use Moody\ConstantContainer;use Moody\InstructionHandler;class InstructionProcessor implements TokenHandlerWithRegister{private static$x=null;private$h=array();private$y=array();const EXECUTE_TYPE_INLINE=1;const EXECUTE_TYPE_DEFAULT=2;public static function getInstance(){if(!self::$x)new self;return self::$x;}private function __construct(){self::$x=$this;TokenVM::globalRegisterTokenHandler(T_COMMENT,$this);foreach(get_declared_classes()as$O){if(in_array('Moody\InstructionHandler',class_implements($O)))$O::getInstance();}}public function execute(Token$L,TokenVM$S){$content=str_replace(array("//","/*","*/","#"),"",$L->content);$z=array();$i0=0;if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$z)){$i1=strtolower($z[1]);if(substr($i1,0,1)=='.')$i1=substr($i1,1);if(isset($this->h[$i1])){if(!($this->h[$i1]instanceof InstructionHandler))throw new InstructionProcessorException('Handler for instruction "'.$z[1].'" does not exist or is not callable',$L);$i0=$this->h[$i1]->execute($L,$z[1],$this,$S);$L->Z=array();goto end;}else if($this->y){foreach($this->y as$t){if(!($t instanceof DefaultInstructionHandler))throw new InstructionProcessorException('Default Handler for instruction "'.$z[1].'" is invalid',$L);if($t->canExecute($L,$z[1],$this)){$i0=$t->execute($L,$z[1],$this,$S,self::EXECUTE_TYPE_DEFAULT);$L->Z=array();goto end;}}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$z[1].'"',$L);}else if(Configuration::get('deletecomments',true))$i0=TokenVM::DELETE_TOKEN;end:return (TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN)^$i0;}public function register(Token$L,TokenVM$S){$content=str_replace(array("//","/*","*/","#"),"",$L->content);$z=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$z)){$i1=strtolower($z[1]);if(substr($i1,0,1)=='.')$i1=substr($i1,1);if(isset($this->h[$i1])&&$this->h[$i1]instanceof InstructionHandlerWithRegister){$this->h[$i1]->register($L,$z[1],$this,$S);$L->Z=array();}}}private function inlineExecute(Token$L){$content=str_replace(array("//","/*","*/","#"),"",$L->content);$z=array();if(preg_match(Configuration::get('requireinstructiondot',true)?'~^\s*(\.([A-Za-z_:\\\0-9]+))~':'~^\s*(\.?[A-Za-z_:\\\0-9]+)~',$content,$z)){$i1=strtolower($z[1]);if(substr($i1,0,1)=='.')$i1=substr($i1,1);if(isset($this->h[$i1])){if(!($this->h[$i1]instanceof InlineInstructionHandler))throw new InstructionProcessorException($z[1].' does not support inline execution',$L);$l=$this->h[$i1]->execute($L,$z[1],$this,null,self::EXECUTE_TYPE_INLINE);$L->Z=array();return$l;}else if($this->y){foreach($this->y as$t){if(!($t instanceof InlineInstructionHandler))continue;if(!($t instanceof DefaultInstructionHandler))throw new InstructionProcessorException('Default handler for instruction "'.$z[1].'" is invalid',$L);if($t->canExecute($L,$z[1],$this))return$t->execute($L,$z[1],$this,null,self::EXECUTE_TYPE_DEFAULT|self::EXECUTE_TYPE_INLINE);$L->Z=array();}}if(!Configuration::get('ignoreunknowninstruction',false))throw new InstructionProcessorException('Unknown instruction "'.$z[1].'"',$L);}}public function registerHandler($i1,InstructionHandler$t){$this->h[$i1]=$t;}public function registerDefaultHandler(DefaultInstructionHandler$t){$this->y[]=$t;}public function parseArguments(Token$i2,$Q,$i3){if($i2->Z)return$i2->Z;if($i3)$i4=str_split($i3);else $i4=array();if(!strpos($i2->content,$Q))throw new InstructionProcessorException('Token corrupted',$i2);if(substr($i2->content,0,2)=='/*')$content=substr($i2->content,2,strrpos($i2->content,'*/')-2);else if(substr($i2->content,0,1)=='#')$content=substr($i2->content,1);else $content=substr($i2->content,2);$i5=substr($content,strpos($content,$Q)+strlen($Q));$a=Token::tokenize('<?php '.$i5.' ?>','Moody Argument Parser');foreach($a as$L)if($L->V==T_COMMA)$i6=true;$i7=0;$i8=0;$i9=$i10=array();$i11=null;parseArgs:foreach($a as$L){if(isset($i12))goto parseArg;if($L->V==T_OPEN_TAG||$L->V==T_CLOSE_TAG||$L->V==T_ROUND_BRACKET_OPEN||$L->V==T_ROUND_BRACKET_CLOSE||$L->V==T_WHITESPACE||in_array($L,$i10))continue;switch($L->V){case T_STRING:if(ConstantContainer::isDefined($L->content))if($i11!==null)$i11.=ConstantContainer::getConstant($L->content);else $i11=ConstantContainer::getConstant($L->content);else $i11.=$L->content;break;case T_CONSTANT_ENCAPSED_STRING:$i11.=eval('return '.$L->content.';');break;case T_TRUE:if($i11!==null)$i11.=true;else $i11=true;break;case T_FALSE:if($i11!==null)$i11.=false;else $i11=false;break;case T_LNUMBER:if($i11!==null)$i11.=(int)$L->content;else $i11=(int)$L->content;break;case T_DNUMBER:if($i11!==null)$i11.=(float)$L->content;else $i11=(float)$L->content;break;case T_NULL:if($i11!==null)$i11.=null;else $i11=null;break;case T_NS_SEPARATOR:$i13="";$i14=key($a)-1;prev($a);while($i15=prev($a)){if($i15->V!=T_STRING)break;end($i9);unset($i9[key($i9)]);$i13=$i15->content.$i13;}while(key($a)!=$i14)next($a);$i13.=$L->content;while($i16=next($a)){if($i16->V!=T_NS_SEPARATOR&&$i16->V!=T_STRING)break;$i13.=$i16->content;$i10[]=$i16;}if(ConstantContainer::isDefined($i13))if($i11!==null)$i11.=ConstantContainer::getConstant($i13);else $i11=ConstantContainer::getConstant($i13);else $i11.=$i13;break;case T_COMMENT:if($i11!==null)$i11.=$this->inlineExecute($L);else $i11=$this->inlineExecute($L);break;case T_COMMA:goto parseArg;default:if($i11!==null)$i11.=$L->content;else $i11=$L->content;}if(isset($i6))continue;parseArg:if(!isset($i4[$i7+$i8])||!$i4[$i7+$i8]){$i9[]=$i11;}else if($i4[$i7+$i8]=='?'){$i8++;goto parseArg;}else {switch(strtolower($i4[$i7+$i8])){default:throw new InstructionProcessorException('Illegal option for argument parser given: '.$i4[$i7+$i8],$i2);case'n':if(is_numeric($i11)&&is_string($i11))$i9[]=(float)$i11;else if(is_int($i11)||is_float($i11)||$i11===null)$i9[]=$i11;else throw new InstructionProcessorException('Illegal argument '.($i7+1).' for '.$Q.': '.gettype($i11).' '.(string)$i11.' given, number expected',$i2);break;case's':if(is_string($i11)||$i11===null)$i9[]=$i11;else throw new InstructionProcessorException('Illegal argument '.($i7+1).' for '.$Q.': '.gettype($i11).' '.(string)$i11.' given, string expected',$i2);break;case'b':if(is_bool($i11)||$i11===null)$i9[]=$i11;else throw new InstructionProcessorException('Illegal argument '.($i7+1).' for '.$Q.': '.gettype($i11).' '.(string)$i11.' given, bool expected',$i2);break;case'x':$i9[]=$i11;}}$i11=null;$i7++;if(isset($i12))break;}if($i11!==null){$i12=true;goto parseArgs;}if((strpos($i3,'?')!==false&&$i7<strpos($i3,'?'))||($i7<count($i4)&&strpos($i3,'?')===false))throw new InstructionProcessorException($Q.' expects '.count($i4).' arguments, '.$i7.' given',$i2);return$i2->Z=$i9;}}}namespace Moody\TokenHandlers{use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class DocCommentHandler implements TokenHandler{private static$x=null;public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_DOC_COMMENT,$this);}public function execute(Token$L,TokenVM$S){if(Configuration::get('deletecomments',false))return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN|TokenVM::DELETE_TOKEN;return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}}}namespace Moody\TokenHandlers{use Moody\Token;use Moody\TokenVM;use Moody\TokenHandler;class OpenTagHandler implements TokenHandler{private static$x=null;public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_OPEN_TAG,$this);}public function execute(Token$L,TokenVM$S){if($L->content=='<?'||$L->content=='<%')$L->content='<?php ';return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}}}namespace Moody\TokenHandlers{use Moody\TokenHandler;use Moody\TokenVM;use Moody\Token;use Moody\Configuration;class VariableHandler implements TokenHandler{private static$x=null;private$i17=array();private$i18="A";public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}private function __construct(){TokenVM::globalRegisterTokenHandler(T_VARIABLE,$this);TokenVM::globalRegisterTokenHandler(T_OBJECT_OPERATOR,$this);}public function execute(Token$L,TokenVM$S){static$i19=array('$this','$_GET','$_POST','$_REQUEST','$_COOKIE','$_ENV','$_SESSION','$_SERVER','$_FILES');if(Configuration::get('compressvariables',false)&&!in_array($L->content,$i19)){if($L->V==T_OBJECT_OPERATOR){if(!Configuration::get('compressproperties',false))return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;$j=$S->getTokenArray();$i20=current($j);if($i20->V!=T_STRING)goto end;while($i21=next($j)){if($i21->V==T_WHITESPACE)continue;if($i21->V==T_ROUND_BRACKET_OPEN)goto end;break;}$i22=$i20;$i22->content='$'.$i22->content;}else $i22=$L;if(!isset($this->i17[$i22->content])){if(!Configuration::get('compressproperties',false)){$j=$S->getTokenArray();prev($j);while($i21=prev($j)){switch($i21->V){case T_STATIC:$i23=true;goto map;default:if(!isset($i23)&&isset($i24))goto end;goto map;case T_PUBLIC:case T_PROTECTED:case T_PRIVATE:$i24=true;case T_WHITESPACE:case T_FORCED_WHITESPACE:continue 2;}}}map:do{$this->mapVariable($i22->content,is_int($this->i18)?'$i'.$this->i18:'$'.$this->i18);if($this->i18==="Z")$this->i18="a";else if($this->i18==="z")$this->i18=0;else if(is_int($this->i18))$this->i18++;else $this->i18=chr(ord($this->i18)+1);}while(count(array_keys($this->i17,$this->i17[$i22->content]))>1);}$i22->content=isset($i20)?substr($this->i17[$i22->content],1):$this->i17[$i22->content];}end:return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}public function mapVariable($i25,$i26){return$this->i17[$i25]=$i26;}}}namespace Moody\TokenHandlers{use Moody\TokenHandler;use Moody\TokenVM;use Moody\Configuration;use Moody\Token;class WhitespaceHandler implements TokenHandler{private static$x=null;public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}private function __construct(){if(Configuration::get('supportwhitespacedeletion',true)){TokenVM::globalRegisterTokenHandler(T_WHITESPACE,$this);TokenVM::globalRegisterTokenHandler(T_ECHO,$this);TokenVM::globalRegisterTokenHandler(T_VARIABLE,$this);TokenVM::globalRegisterTokenHandler(T_GOTO,$this);TokenVM::globalRegisterTokenHandler(T_ELSE,$this);TokenVM::globalRegisterTokenHandler(T_NAMESPACE,$this);TokenVM::globalRegisterTokenHandler(T_CONST,$this);TokenVM::globalRegisterTokenHandler(T_NEW,$this);TokenVM::globalRegisterTokenHandler(T_INSTANCEOF,$this);TokenVM::globalRegisterTokenHandler(T_INSTEADOF,$this);TokenVM::globalRegisterTokenHandler(T_STRING,$this);TokenVM::globalRegisterTokenHandler(T_CLASS,$this);TokenVM::globalRegisterTokenHandler(T_EXTENDS,$this);TokenVM::globalRegisterTokenHandler(T_PUBLIC,$this);TokenVM::globalRegisterTokenHandler(T_PROTECTED,$this);TokenVM::globalRegisterTokenHandler(T_PRIVATE,$this);TokenVM::globalRegisterTokenHandler(T_FINAL,$this);TokenVM::globalRegisterTokenHandler(T_STATIC,$this);TokenVM::globalRegisterTokenHandler(T_FUNCTION,$this);TokenVM::globalRegisterTokenHandler(T_RETURN,$this);TokenVM::globalRegisterTokenHandler(T_CASE,$this);TokenVM::globalRegisterTokenHandler(T_START_HEREDOC,$this);TokenVM::globalRegisterTokenHandler(T_SEMICOLON,$this);TokenVM::globalRegisterTokenHandler(T_END_HEREDOC,$this);TokenVM::globalRegisterTokenHandler(T_BREAK,$this);TokenVM::globalRegisterTokenHandler(T_CONTINUE,$this);TokenVM::globalRegisterTokenHandler(T_USE,$this);TokenVM::globalRegisterTokenHandler(T_THROW,$this);TokenVM::globalRegisterTokenHandler(T_INTERFACE,$this);TokenVM::globalRegisterTokenHandler(T_TRAIT,$this);TokenVM::globalRegisterTokenHandler(T_IMPLEMENTS,$this);}}public function execute(Token$L,TokenVM$S){if(Configuration::get('deletewhitespaces',false)){switch($L->V){case T_WHITESPACE:$j=$S->getTokenArray();if(($i21=current($j))&&$i21->V==T_END_HEREDOC)$this->insertForcedWhitespace($S,true);return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN|TokenVM::DELETE_TOKEN;case T_ECHO:case T_RETURN:case T_PUBLIC:case T_PROTECTED:case T_PRIVATE:case T_STATIC:case T_FINAL:case T_CASE:case T_CONTINUE:case T_BREAK:case T_THROW:$j=$S->getTokenArray();if($i21=current($j)){if($i21->V!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i21=next($j))&&$i21->V!=T_CONSTANT_ENCAPSED_STRING&&$i21->V!=T_VARIABLE)$this->insertForcedWhitespace($S);}break;case T_VARIABLE:$j=$S->getTokenArray();if($i21=current($j)){if($i21->V!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i21=next($j))&&($i21->V==T_AS||$i21->V==T_INSTANCEOF))$this->insertForcedWhitespace($S);}break;case T_GOTO:case T_NAMESPACE:case T_CONST:case T_NEW:case T_INSTANCEOF:case T_INSTEADOF:case T_CLASS:case T_EXTENDS:case T_FUNCTION:case T_START_HEREDOC:case T_USE:case T_INTERFACE:case T_TRAIT:case T_IMPLEMENTS:$this->insertForcedWhitespace($S);break;case T_ELSE:$j=$S->getTokenArray();if($i21=current($j)){if($i21->V!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i21=next($j))&&$i21->V!=T_CURLY_OPEN)$this->insertForcedWhitespace($S);}break;case T_STRING:$j=$S->getTokenArray();if($i21=current($j)){if($i21->V!=T_WHITESPACE)return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;else if(($i21=next($j))&&($i21->V==T_EXTENDS||$i21->V==T_INSTEADOF||$i21->V==T_INSTANCEOF||$i21->V==T_AS||$i21->V==T_IMPLEMENTS))$this->insertForcedWhitespace($S);}break;case T_SEMICOLON:$j=$S->getTokenArray();prev($j);$i21=prev($j);if($i21->V==T_END_HEREDOC)$this->insertForcedWhitespace($S,true);break;case T_END_HEREDOC:$j=$S->getTokenArray();if(($i21=current($j))&&$i21->V!=T_SEMICOLON)$this->insertForcedWhitespace($S,true);break;}}end:return TokenVM::NEXT_HANDLER|TokenVM::NEXT_TOKEN;}private function insertForcedWhitespace(TokenVM$S,$i27=false){$L=new Token;$L->content=$i27?"\r\n":" ";$L->V=T_FORCED_WHITESPACE;$L->X="Moody WhitespaceHandler";$S->insertTokenArray(array($L));}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class BooleanCastHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('bool',$this);InstructionProcessor::getInstance()->registerHandler('boolean',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'x');if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return (bool)$i9[0];$L->content=Token::makeEvaluatable((bool)$i9[0]);return 0;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\DefaultInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class CallHandler implements InlineInstructionHandler,DefaultInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('call',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){if($T&InstructionProcessor::EXECUTE_TYPE_DEFAULT){$i28=substr($Q,0,1)=='.'?substr($Q,1):$Q;$i9=$R->parseArguments($L,$Q,'');$i9[0]=$i28;}else {$i9=$R->parseArguments($L,$Q,'s');$i28=$i9[0];}if(strpos($i28,'::')){$i29=explode('::',$i28,2);$i28=array($i29[0],$i29[1]);if(!method_exists($i29[0],$i29[1]))throw new InstructionProcessorException($i9[0].'() does not exist',$L);}else if(!function_exists($i28))throw new InstructionProcessorException($i9[0].'() does not exist',$L);if(!is_callable($i28))throw new InstructionProcessorException($i9[0].'() is not callable from the current scope',$L);$i30=$i9;if(!($T&InstructionProcessor::EXECUTE_TYPE_DEFAULT))unset($i30[0]);$D=call_user_func_array($i28,$i30);if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return$D;$L->content=Token::makeEvaluatable($D);return 0;}public function canExecute(Token$L,$Q,InstructionProcessor$R){if(substr($Q,0,1)=='.')$Q=substr($Q,1);if(strpos($Q,'::')){$i29=explode('::',$Q,2);if(!method_exists($i29[0],$i29[1]))return false;}else if(!function_exists($Q))return false;return true;}}}namespace Moody\InstructionHandlers{use Moody\Configuration;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ConfigurationHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('config',$this);InstructionProcessor::getInstance()->registerHandler('configuration',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'s?x');if(!isset($i9[1])){if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return Configuration::get($i9[0],null);$L->content=Token::makeEvaluatable(Configuration::get($i9[0],null));return 0;}else Configuration::set($i9[0],$i9[1]);return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\DefaultInstructionHandler;use Moody\InstructionHandler;use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class GetConstantHandler implements InlineInstructionHandler,DefaultInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('const',$this);InstructionProcessor::getInstance()->registerHandler('constant',$this);InstructionProcessor::getInstance()->registerHandler('getconstant',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){if($T&InstructionProcessor::EXECUTE_TYPE_DEFAULT)$i9=array(substr($Q,0,1)=='.'?substr($Q,1):$Q);else $i9=$R->parseArguments($L,$Q,'s');if(!ConstantContainer::isDefined($i9[0]))throw new InstructionProcessorException($Q.': Undefined constant: '.$i9[0],$L);$i31=ConstantContainer::getConstant($i9[0]);if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return$i31;$L->content=Token::makeEvaluatable($i31);return 0;}public function canExecute(Token$L,$Q,InstructionProcessor$R){if($R->parseArguments($L,$Q,''))return false;if(!ConstantContainer::isDefined(substr($Q,0,1)=='.'?substr($Q,1):$Q))return false;return true;}}}namespace Moody\InstructionHandlers{use Moody\DefaultInstructionHandler;use Moody\ConstantContainer;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;class DefineHandler implements InstructionHandler,DefaultInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('define',$this);InstructionProcessor::getInstance()->registerHandler('def',$this);InstructionProcessor::getInstance()->registerHandler('d',$this);InstructionProcessor::getInstance()->registerDefaultHandler($this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){if($T&InstructionProcessor::EXECUTE_TYPE_DEFAULT){$i9=$R->parseArguments($L,$Q,'sx');$G=substr($Q,0,1)=='.'?substr($Q,1):$Q;$i32=array('(',')','+','-','*','/','|','&','^','>>','<<');$i33="";foreach($i9 as$i34=>$i35){if(!$i34)continue;if(!is_int($i35)&&!in_array($i35,$i32))$i36=false;$i33.=$i35;}if(isset($i36))$D=$i33;else if(($D=eval('return ('.$i33.');'))===false)throw new InstructionProcessorException('Math syntax error');switch($i9[0]){case'=':ConstantContainer::define($G,$D);break;case'.=':ConstantContainer::define($G,ConstantContainer::getConstant($G).$D);break;case'+=':ConstantContainer::define($G,ConstantContainer::getConstant($G)+$D);break;case'-=':ConstantContainer::define($G,ConstantContainer::getConstant($G)-$D);break;case'*=':ConstantContainer::define($G,ConstantContainer::getConstant($G)*$D);break;case'/=':ConstantContainer::define($G,ConstantContainer::getConstant($G)/$D);break;case'|=':ConstantContainer::define($G,ConstantContainer::getConstant($G)|$D);break;case'^=':ConstantContainer::define($G,ConstantContainer::getConstant($G)^$D);break;case'&=':ConstantContainer::define($G,ConstantContainer::getConstant($G)&$D);break;case'>>=':ConstantContainer::define($G,ConstantContainer::getConstant($G)>>$D);break;case'<<=':ConstantContainer::define($G,ConstantContainer::getConstant($G)<<$D);break;}}else {$i9=$R->parseArguments($L,$Q,'sx');ConstantContainer::define($i9[0],$i9[1]);}return TokenVM::DELETE_TOKEN;}public function canExecute(Token$L,$Q,InstructionProcessor$R){$i9=$R->parseArguments($L,$Q,'');$i32=array('=','.=','+=','-=','*=','/=','|=','&=','^=','<<=','>>=');if(in_array($i9[0],$i32)&&!($i9[0]!='='&&!ConstantContainer::isDefined(substr($Q,0,1)=='.'?substr($Q,1):$Q)))return true;return false;}}}namespace Moody\InstructionHandlers{use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class EchoHandler implements InstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('echo',$this);InstructionProcessor::getInstance()->registerHandler('print',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'x');foreach($i9 as$i35)echo (string)$i35;return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\END_TOKEN_NO_EXECUTE;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ElseHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('else',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getToken()==$L){if(!($i1->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$Q.' - Probably you forgot an endif?',$L);$i37=$i1;}}foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getEndToken()==$L){if($i1->getEndTokenAction()==\Moody\END_TOKEN_NO_EXECUTE){$i37->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);$S->jump($i37->getEndToken());return TokenVM::DELETE_TOKEN|TokenVM::JUMP;}}}return TokenVM::DELETE_TOKEN;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){MultiTokenInstruction::setEndToken($L,'if');new MultiTokenInstruction($L,'if');}}}namespace Moody\InstructionHandlers{use Moody\END_TOKEN_NO_EXECUTE;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ElseIfHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('elseif',$this);InstructionProcessor::getInstance()->registerHandler('elif',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getToken()==$L){if(!($i1->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$Q.' - Probably you forgot an endif?',$L);$i37=$i1;}}foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getEndToken()==$L){if($i1->getEndTokenAction()==\Moody\END_TOKEN_NO_EXECUTE){$i37->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);$S->jump($i37->getEndToken());return TokenVM::DELETE_TOKEN|TokenVM::JUMP;}}}return IfHandler::getInstance()->execute($L,$Q,$R,$S);}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){MultiTokenInstruction::setEndToken($L,'if');new MultiTokenInstruction($L,'if');}}}namespace Moody\InstructionHandlers{use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class EndLongDefineHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endlongdefine',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){return TokenVM::DELETE_TOKEN;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){MultiTokenInstruction::setEndToken($L,'longDefine');}}}namespace Moody\InstructionHandlers{use Moody\TokenHandlers\InstructionProcessor;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenVM;use Moody\MultiTokenInstruction;class EndIfHandler implements InstructionHandlerWithRegister{private static$x;private function __construct(){InstructionProcessor::getInstance()->registerHandler('endif',$this);}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){return TokenVM::DELETE_TOKEN;}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){MultiTokenInstruction::setEndToken($L,'if');}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class EvalHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('eval',$this);InstructionProcessor::getInstance()->registerHandler('evaluate',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'s?bb');if(!isset($i9[1])||$i9[1]===true){if(!strpos($i9[0],'<?')){$i38=true;$j=Token::tokenize('<?php '.$i9[0].' ?>',$Q.' code');}else $j=Token::tokenize($i9[0],$Q.' code');$S=new TokenVM();try{$j=$S->execute($j);}catch(\Exception$i39){echo (string)$i39."\r\n";exit;}if(isset($i38)){reset($j);unset($j[key($j)]);end($j);unset($j[key($j)]);}$i9[0]="";foreach($j as$i40){$i9[0].=$i40->content;}}$i41=eval($i9[0]);if($i41!==null){if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return$i41;$L->content=!isset($i9[2])||$i9[2]===true?Token::makeEvaluatable($i41):$i41;return 0;}return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class ExitHandler implements InstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('exit',$this);InstructionProcessor::getInstance()->registerHandler('halt',$this);InstructionProcessor::getInstance()->registerHandler('quit',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){return TokenVM::QUIT|TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class GotoHandler implements InstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('goto',$this);InstructionProcessor::getInstance()->registerHandler('jump',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'s');$i42=LabelHandler::getLabel($i9[0]);if(!($i42 instanceof Token))throw new InstructionProcessorException('Jump to undefined label '.$i9[0],$L);$S->jump($i42);return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\END_TOKEN_ELSE;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IfHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('if',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'x');foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getToken()==$L){if(!($i1->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$Q.' - Probably you forgot an endif?',$L);$i43="";$i41=false;foreach($i9 as$i35){if(is_string($i35)&&strlen($i35)&&strtolower($i35)!=="true"&&strtolower($i35)!=="false"){$a=Token::tokenize('<?php '.$i35.' ?>');if($a[1]->V==T_STRING)$i35=Token::makeEvaluatable($i35);}else if(is_string($i35)&&!strlen($i35))$i35="''";if($i35===true)$i35="true";else if($i35===false)$i35="false";else if($i35===null)$i35="null";$i43.=$i35;}$i41=eval('return (int) (bool) ('.$i43.');');if($i41===1){$i1->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);return TokenVM::DELETE_TOKEN;}if($i41===false)throw new InstructionProcessorException('If-condition '.$i43.' is invalid',$L);$i1->setEndTokenAction(\Moody\END_TOKEN_EXECUTE);$S->jump($i1->getEndToken());return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}return TokenVM::ERROR;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){new MultiTokenInstruction($L,'if');}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IfDefHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifdef',$this);InstructionProcessor::getInstance()->registerHandler('ifdefined',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'s');foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getToken()==$L){if(!($i1->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$Q.' - Probably you forgot an endif?',$L);if(ConstantContainer::isDefined($i9[0])){$i1->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);return TokenVM::DELETE_TOKEN;}$S->jump($i1->getEndToken());$i1->setEndTokenAction(\Moody\END_TOKEN_EXECUTE);return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}return TokenVM::ERROR;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){new MultiTokenInstruction($L,'if');}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\InstructionHandlerWithRegister;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IfNotDefHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('ifndef',$this);InstructionProcessor::getInstance()->registerHandler('ifnotdefined',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'s');foreach(MultiTokenInstruction::getAll('if')as$i1){if($i1->getToken()==$L){if(!($i1->getEndToken()instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$Q.' - Probably you forgot an endif?',$L);if(!ConstantContainer::isDefined($i9[0])){$i1->setEndTokenAction(\Moody\END_TOKEN_NO_EXECUTE);return TokenVM::DELETE_TOKEN;}$S->jump($i1->getEndToken());$i1->setEndTokenAction(\Moody\END_TOKEN_EXECUTE);return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}}return TokenVM::ERROR;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){new MultiTokenInstruction($L,'if');}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IncludeHandler implements InstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('include',$this);InstructionProcessor::getInstance()->registerHandler('inc',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'s');if(!file_exists($i9[0]))throw new InstructionProcessorException($i9[0].' does not exist',$L);if(!is_readable($i9[0]))throw new InstructionProcessorException($i9[0].' is not readable - Make sure Moody has the rights to read it',$L);$d=file_get_contents($i9[0]);$a=Token::tokenize($d,$i9[0]);switch($a[0]->V){case T_OPEN_TAG:unset($a[0]);break;case T_INLINE_HTML:$L=new Token;$L->V=T_CLOSE_TAG;$L->content=" ?>";$i44=array($L);foreach($a as$L)$i44[]=$L;$a=$i44;}end($a);switch(current($a)->V){case T_CLOSE_TAG:unset($a[key($a)]);break;case T_INLINE_HTML:$L=new Token;$L->V=T_OPEN_TAG;$L->content="<?php ";$a[]=$L;}$S->insertTokenArray($a);return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class InputHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('input',$this);InstructionProcessor::getInstance()->registerHandler('getinput',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'?n');if(!defined('STDIN')||!is_resource(\STDIN))throw new InstructionProcessorException('No input stream available',$L);$D=fread(\STDIN,isset($i9[0])?$i9[0]:1024);if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return$D;$L->content=Token::makeEvaluatable($D);return 0;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class IsDefinedHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('isdefined',$this);InstructionProcessor::getInstance()->registerHandler('isdef',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'s');if(ConstantContainer::isDefined($i9[0])){if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return true;$L->content=Token::makeEvaluatable(true);}else {if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return false;$L->content=Token::makeEvaluatable(false);}return 0;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class LabelHandler implements InstructionHandlerWithRegister{private static$x=null;private static$i45=array();private function __construct(){InstructionProcessor::getInstance()->registerHandler('label',$this);InstructionProcessor::getInstance()->registerHandler('jumplabel',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){return TokenVM::DELETE_TOKEN;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'s');if(isset(self::$i45[$i9[0]]))throw new InstructionProcessorException('Double definition of jump label "'.$i9[0].'" (first definition at '.self::$i45[$i9[0]]->X.':'.self::$i45[$i9[0]]->Y,$L);self::$i45[$i9[0]]=$L;}public static function getLabel($I){if(isset(self::$i45[$I]))return self::$i45[$I];}}}namespace Moody\InstructionHandlers{use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;use Moody\InstructionProcessorException;use Moody\MultiTokenInstruction;use Moody\ConstantContainer;class LongDefineHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('longdefine',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'s');foreach(MultiTokenInstruction::getAll('longDefine')as$i1){if($i1->getToken()==$L){$M=$i1->getEndToken();if(!($M instanceof Token))throw new InstructionProcessorException('Invalid end token for '.$Q.' - Probably you forgot an endLongDefine?',$L);$a=$S->getTokenArray();$i46="";while($L=current($a)){if($L==$M){ConstantContainer::define($i9[0],$i46);$S->jump($L);return TokenVM::JUMP|TokenVM::DELETE_TOKEN;}$i46.=$L->content;next($a);}}}return TokenVM::ERROR;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){new MultiTokenInstruction($L,'longDefine');}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class MacroHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('macro',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){if(strtolower($Q)=='.macro'){if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)throw new InstructionProcessorException($Q.' does not support inline execution',$L);$i9=$R->parseArguments($L,$Q,'ss');if(!strlen($i9[0]))throw new InstructionProcessorException('Macro name cannot be empty',$L);$i47=new Macro(strtolower($i9[0]),$i9[1]);$R->registerHandler(strtolower($i9[0]),$this);unset($i9[0],$i9[1]);foreach($i9 as$i35)$i47->addArgument($i35);return TokenVM::DELETE_TOKEN;}$i48=substr(strtolower($Q),1);$i47=Macro::getMacro($i48);if(!$i47)throw new InstructionProcessorException('Call to bad macro',$L);$i4="";for($i49=0;$i49<$i47->numArgs();$i49++)$i4.='x';$i9=$R->parseArguments($L,$Q,$i4);if($T&InstructionProcessor::EXECUTE_TYPE_INLINE){$code="";foreach($i47->buildCode($i9)as$L)$code.=$L->content;return$code;}else $S->insertTokenArray($i47->buildCode($i9));return TokenVM::DELETE_TOKEN;}}class Macro{private$I="";private$code="";private$i50=array();private static$i51=array();public function __construct($I,$code){$this->I=$I;$this->code=$code;self::$i51[$I]=$this;}public function addArgument($i52){$this->i50[]=$i52;}public function numArgs(){return count($this->i50);}public function buildCode($i9=array()){$i49=0;$code=$this->code;foreach($this->i50 as$i35){$code=str_replace($i35,$i9[$i49],$code);$i49++;}$a=Token::tokenize('<?php '.$code,'Macro '.$this->I);unset($a[0]);return$a;}public static function getMacro($I){if(isset(self::$i51[$I]))return self::$i51[$I];}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenHandlers\VariableHandler;use Moody\TokenVM;class MapVariableHandler implements InstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('mapvariable',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'ss');if(!class_exists('Moody\TokenHandlers\VariableHandler'))throw new InstructionProcessorException('Variable mapping is not available as the token handler for T_VARIABLE is not currently loaded',$L);VariableHandler::getInstance()->mapVariable($i9[0],$i9[1]);return TokenVM::DELETE_TOKEN;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class NumberCastHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('number',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'x');if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return (float)$i9[0];$L->content=Token::makeEvaluatable((float)$i9[0]);return 0;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class RaiseErrorHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('raiseerror',$this);InstructionProcessor::getInstance()->registerHandler('error',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'s');throw new InstructionProcessorException($i9[0],$L);}}}namespace Moody\InstructionHandlers{use Moody\Configuration;use Moody\InstructionHandlerWithRegister;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class RegisterConfigurationHandler implements InstructionHandlerWithRegister{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('registerconfiguration',$this);InstructionProcessor::getInstance()->registerHandler('registerconfig',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){return TokenVM::DELETE_TOKEN;}public function register(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'sx');Configuration::set($i9[0],$i9[1]);}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InlineInstructionHandler;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class StringCastHandler implements InlineInstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('string',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S=null,$T=0){$i9=$R->parseArguments($L,$Q,'x');if($T&InstructionProcessor::EXECUTE_TYPE_INLINE)return (string)$i9[0];$L->content=Token::makeEvaluatable((string)$i9[0]);return 0;}}}namespace Moody\InstructionHandlers{use Moody\InstructionProcessorException;use Moody\InstructionHandler;use Moody\ConstantContainer;use Moody\Token;use Moody\TokenHandlers\InstructionProcessor;use Moody\TokenVM;class UndefineHandler implements InstructionHandler{private static$x=null;private function __construct(){InstructionProcessor::getInstance()->registerHandler('undef',$this);InstructionProcessor::getInstance()->registerHandler('undefine',$this);}public static function getInstance(){if(!self::$x)self::$x=new self;return self::$x;}public function execute(Token$L,$Q,InstructionProcessor$R,TokenVM$S){$i9=$R->parseArguments($L,$Q,'s');if(!ConstantContainer::isDefined($i9[0]))throw new InstructionProcessorException($Q.': Undefined constant: '.$i9[0],$L);ConstantContainer::undefine($i9[0]);return TokenVM::DELETE_TOKEN;}}}?>